v Check Eltorito bootsector specification for CDROM.
  Currently a floppy is emulated.

  DONE: see DOC/Bootsector.txt


v include acpi.s breaks as [acpi code not committed]
  Filed bug report. 


v: bootloader writing. Currently destroys the target disk's previous
   data, as it writes to the MBR and succeeding sectors.

TODO: bootloader writing: write sector1 and following in the place indicated
  by the MBR. If writing to existing partition, allocate space using
  it's filesystem.

v: PMode. Provide: GDT (Global Descriptor Table)

v: Pmode IDT (Interrupt Table)

v: PIC remapping

v: implement keyboard driver in PMode (depends IDT)

TODO: Task Switching (TSS) (depends PMode)
  partly done - one TSS switch already works. Need to check whether
  a context switch really occurs to make sure.

v construct memory map (ebda, bios rom etc).
  using realmode kernel int 0x12 and int 0x15 to pass map to pmode.
  malloc makes use of the largest block.

TODO: implement Paging
  since it cannot be turned off and it seems like a nightmare it is postponed.

TODO: test acpi_poweroff

v: Shell
  extremely small shell with history, environment variables, and a built-in
  command list. Shell is run from kernel, can be exited to return to
  stage 2 bootloader, which offers shutdown and reboot.

TODO: filesystem
   implemented fdisk.
   implemented FAT16 read access.
   started on 'sfs', custom filesystem. Something akin to git seems worth
   considering.

v: clean up bootloader, separate from kernel. Decisions:
	- whether sector1 is the kernel, or whether it is additional
	  bootloader code. At some point the kernel/sector1 will not
	  be succeeding the bootsector immediately, if compatability
	  with multi-os prepartitioned harddisks is desired.

	* Solution chosen is to separate sector1 into a stage 2 loader
	  and a kernel. The stage 2 loader at current uses a 'ramdisk',
	  a sector marking the start and length of images to be loaded.
	  At current only the first entry is used.
	  The kernel itself will check a signature at the end of it's compiled
	  code+data length to see if it is loaded in its entirety.
	
	- splitting: where to split sector1 from the kernel, where
	  is pmode entered? Goal is to use as little duplicate code as
	  possible.

	* Sector 1 used to include menu, inspector, pmode code. 
	  The 16 bit utilities have been moved and can still be included
	  in sector1, which now only contains the second stage loader code.
	  The pmode code has been moved to the kernel, aswell as all other
	  32 bit code.

	- whether to load the kernel in realmode or in pmode

	* The kernel is loaded in realmode. Loading in pmode would require:
	  o ATA (IDE) drivers; or
	  o VM86 task and monitor to allow BIOS calls; or
	  o switching to realmode for BIOS calls.

	  cons: the kernel loader code would already contain kernel code.
	  pros: kernel size can exceed the availale realmode size
	  of 0xf0000 - 0x4000 = 0xec000 = 966656 bytes = 944 kb when preserving
	  the IVT and BIOS - EBDA may be even before this.

	- whether to implement pmode drivers or do v86/realmode switching

	* Drivers shall be implemented in pmode. The current design then
	  has switched from a monolithic kernel which may grow too big,
	  to a microkernel with loadable modules.
	  The core functionality of the kernel then is to offer BIOS
	  functionality in protected mode: interrupts, irq (keyboard),
	  and storage device handlers.

	* realmode switching implemented to call VESA graphics bios.


TODO: load modules/objects/programs

TODO: have the sector1 code switch to pmode asap,
and update all the code used to linear addressing.
pmode needed for ACPI. 

TODO: create assembler

TODO: create high level programming language compiler

TODO: VM98 Mode (depends TSS)
  postponed, due to realmode switching availability.

v: IO APIC

TODO: Local APIC (xAPIC)
  postponed until SMP.

TODO: ELF Loader, KFS
	Compile (g++ test.c && objcopy -O elf32-i386 test.o test.o)
	Add to boot.img (write.exe ... -b test.o)
	Modify bootloader: pass on pointer to RAMDISK0
	Add code to kernel to access RAMDISK0 location - KFS.
	Load entry 1 (0=kernel), ELF image.
	Support REL and EXE; in case of EXE subtract base address from
	addresses to make 0-aligned.
	Iterate over relocation table:
		for each symbol update address:
			use kernel ELF image to locate symbol (and its address).
	Change makefile: store REL ELF binary of kernel image. 
	Update loader: locate .text section address (optionally add the
	entry address), and transfer control there.
		Pitfall: there will be data before and after the text section,
		so, need to make sure that the .text and .data sections
		are properly aligned in memory. Likely the ELF format
		does this properly. I assume that the ELF headers and tables
		will be stored before the blocks of data.
		(as to not replicate too much ELF code in the 16 bit loader)
	Keep track of all loaded ELF images as they will be the basis
	for the processes. 
	Finish kernel memory map: it already has access to the realmode
	data bios memory map. Needs to find a suitable memory segment
	for the kernel, for dynamic data maintenance, and for
	processes. Initial approach: take biggest memory segment,
	it'll be last usable one, above 1MB, extending to a little before
	physical memory end - the final segment of unusable data. Make sure
	algorithm can operate on any map ordering.
	Add relocation code. Perhaps split up the pmode code to have it just
	switch to pmode with all interrupts disabled,
	then return to the realmode loader code, do a memory move,
	then continue on with the setup of interrupts etc. Could also
	have the kernel do this, as the GDT needs to be adjusted:
		disable interrupts
		memmove
		update gdt (need to create 32 bit code)
		either zero out the lomem and use memory mapping,
		or zero out just the 32 bit part and keep track of
		the 16 bit kernel location and size.
	
	Investigate Local Descriptor Table. It may be possible to create
	new descriptors without modifying the GDT. In this case,
	create a segment descriptor for code, with limits according to
	the ELF information, aswell as a data selector and a stack
	selector. Find out what exception is generated for data overflows,
	potentially dynamic allocation (i.e. store parameters in registers,
	then access the last address the program expects to be addressable,
	having the gpf detect signature values in the registers to treat
	it like a malloc call.).

	Also, reserve some space BEFORE the elf header for a few simple
	pointers - heap start/end, stack etc.

	Implement ELF translation: assuming the entire image is in memory,
	create a copy by joining the appropriate sections; keep the sections
	(such as symboltable) that are useful.

	Decide whether to keep all process information together:
	process-header | elf headers | symboltable | code | data | stack | heap
	or whether to keep data of the same contextuals scope together:
	process-headers, symboltable... This allows for process mem layout
	to be STACK | CODE | DATA | HEAP.
	Otherwise: PROCESS INFO | LINKAGE | CODE | DATA | STACK | bss | HEAP

	Code needs an API to get a hold of brk()/heap start and end.
	Could either offer a pointer to the process layout, or specify
	a struct, such as     PROCESS INFO | CODE | DATA | ....
	or offer a kernel method that the linkage will refer to.


	ELF MODIFICATIONS:
	add new section type or use .notes or something to record library
	names and versions the file should be linked against. (cant check
	since creating an elf binary on cygwin needs to go through lots of
	weird options (-Wl,--oformat=elf32-i..), but -shared wont work...)
	
	Alternatively, encode the symbol names with library info,
	perhaps an index number into the new section. At current
	all symbols seem to be global, and only parameterizable by section,
	unless the compiler is changed to create elf files with split
	sections for symbol tables (referring to the same progbits/data),
	each section also recording the api name of the library.


Shell: argument escaping

	Use the parsed tokens, write a little grammar for them:
	see process_tokens in shell.s and trash/cd_apply.s

	trashed for now. Tokenizer on character classes is used, along
	with a token merger.

v FileSystem: cd, ls

	implemented fs_opendir/fs_nextentry/fs_openfile/fs_handle_read;
	cd, ls, cat.

	volumes can be mounted in any (nonexistent or existent) directory
	and take precedence, potentially shadowing a filesystem mounted
	in a parent directory.

	Each filesystem type has its own implementation (bits and
	pointers stored in the mtab).
	
	v First attempt: simply only the ability to 
		mount hdb0 /a
		cd /a
		ls
	v next attempt:
		mount hdb0 /a
		ls /a
	v When this is unified, the next attempt is:
		ls /a/directory


v mtab / mount: Mounting filesystems:
	(mounting partitions already works, recording wise).

	v Filesystems may be mounted on top of anything, so opendir
	  should check for the longest match in mtab in order to find
	  the proper filesystem handing code;
	  for permissions and such, a top down approach should be applied.

	v The opendir implementation checks mtab for each directory in the
	  given absolute path.
	  if there is no match it delegates to the current filesystem handler.
	  An interface to hold directory information in a generic format is
	  filled by filesystems. Generic handles are used to keep track
	  of the pointers and allocated buffers.

	The root handler then is the 'memory filesystem', containing
	the virtual root and the mount points,
	aswell as any other custom filesystems (such as a kernel filesystem
	or /dev and such).

	right now the mount point does not have to exist in order to mount
	there.

	
- i8254 does not immediately send packets, only when there are a number of
  them. Possibly due to descriptor ring flags not being cleared properly.

v realmode 'data' is slowly being pushed outside of the 64k range.
  option 1) Consider separating the realmode/pmode code, as the binary formats
    do not allow interleaving code/data segments. So, compile 2 obj files,
    and copy them. Don't want to use elf loading here as the code would need
    to be duplicated in pmode.
  option 2) define all data in .text for realmode/pmode/gdt/idt, anything
    doubly referenced.
  option 3) have a quick enter-pmode in the realmode.s, and
    do the dynamic setup of the GDT in pmode.s.

  DONE: option 2.

  Kernel image layout:

  .text
  - realmode code (.text16 macro)
  - realmode data (.data16 macro)
  - protected mode code (.text32 macro)
  .data
  - protected mode data
    - general data
    - pointer arrays
    - strings
    - driver metadata (pci id's, initialisation code)
    - bss [uninitialized data]. (.bss not supported).


IMPROVEMENT: Optimize static string storage:

	the LOAD_TXT and similar macros define strings in the string
	section.
	Add a tool that rewrites the object file, removing duplicate
	strings, and using offsets into strings and such
	(.e. a="eax", b="ax" => a = "eax", b = a + 1)
	and using the elf/coff string tables to update references
	in code and data.

BUG: fdisk: ata_(get|print)_capacity reports 0 in VMWare

BUG: ata: sometimes DRQ timeout in VMWare.
  When this happens, gfx mode no longer works.
  Suspect filesystem handle freeing.
  ata reports ERR and ABRT occasionally - need to find out how to reset.

TODO: implement IDE DMA.

BUG: hash: pci device array reallocation does not work properly;
  part of a nic structure is not copied. Found out due to a buffer pointer
  being zero causing GPF. As a side effect hardware breakpoints are implemented
  which revealed the culprit on memory write.


TODO: offload screen writing in interrupts

  pinging < 1ms, even when print on packet within isr.

  However, time becomes about 12 ms when the screen needs to be scrolled with
  SCREEN_BUFFER enabled, and half that without screen buffer.
  Using movsd instead of movsd reduces it from 6 to 3. The first ping is 
  then 1 ms.

  Wwen doing a similar movsw without referencing video memory the ping
  times become < 1ms again.

  Thus i suspect that on memory access vmware steps in and does a screen update.

  See DOC/TaskSwitching.txt

BUG: On resume after hibernate of host os, qemu's nic irq/scheduler doesn't trigger.

BUG: since fixing strtok and fs_update_path, the directory is no longer trailed by /.
     cd /b then yields dir /b, not /b/, thus catting a file F yields path /bF.
WORKAROUND: cd /b/

FIXED: symboltable is loaded after kernel's BSS. Stack may run into it, as it is
  64/128 kb beyond kernel end, not beyond symtab end.

FIXED: bootloader's ramdisk kernel load end is before end of bss. This was due
  to not taking the ramdisk FAT into account. Bug was detected by new '-s' option
  to mem.

BUG: occasionally 0x00000000 is called on ARP error from incoming connection.


TODO: fat12 long filenames

TODO: iso9660 RR extensions for long filenames

TODO: use cld in IRQ proxies (and the core IRQ handler), as this is assumed,
	yet some code uses std...cld, which might cause problems when IRQ's
	are fired inbetween.


TODO: Multitasking: shell.
  v Make shell multi-instantiable, i.e. object.
  - Have 'alt-2' open another console shell
  - contextualize print routines: have an array/pointer to a struct
    containing the pointer to the buffer and screenpos.
    (alternate approach: have a print-object layer that can also be used
    to print to files etc).
  v create method to allocate a task/process context: object + stack.
  v implement process array - reserve first N for console windows (or use
    second array). Alt-NR activates (creates if nonexistent).
  - update kernel context/IP pointer to a hlt loop, checking how many
    processes are running. Add this context as the 0th context.
  - process layout:
     - kernel in hlt loop (idle task?)
     - kb handler checking console activation
     - when console activated, no process is allocated yet
     - enter creates shell process.
     - scheduler updates:
       - round robin scan (skipping gaps).
       - increase task entry struct with flags: one-shot or process.
       - for task flags, the parameter buffer contains all registers.
       - the task executed is executed as usual. A proxy task is used
         for task switches, which uses the data pointed to by edx to configure
	 the registers. TODO: look into using TSS for this.
       - look into a clean exit from the scheduler, as the scheduler will
         have a signature on the stack of whatever process was running,
	 which may cause problems when the scheduler is invoked and schedules
	 that same process again.
	 Requires to unwind stack (add esp, x), and save the cs:eip:flags
	 (aswell as all other registers) in the currently executing task's
	 arguments. The return into the current task is then aborted,
	 and reengaged when the scheduler reencounters the task.
	 Initial approach:
	 - unaware of current task. Simply append a task_switch task to the
	   task queue, parameterized with all registers.
	 - abort returning to currently executing task, and run a task from
	   the queue. If there is no task on the queue, switch to a debug
	   task that prints the time on the screen.



TODO: Multitasking: ring 3.
  - update exe (elf) loader to allocate stack.
  update: use schedule_task; depends todo: - suspend parent scheduling
  while child process runs; implement ^Z to suspend child and schedule parent.
  implement job stack.

TODO: implement I/O pipes for IPC: chaining commandline processes.
 
TODO: string data optimizer:
  works on .o file (perhaps conversion to ELF and back).
  works on data between symbol locations section_data_str_(start|end).
  removes duplicate strings (saves 2k); uses matching suffix strings.
  Requires symbols to be stored in the .o to find the string references.

  Approach: declare a section .strtab (as a .data area takes about 10kb).
  This area contains fields of 2 dwords: the string data offset, and the
  code offset (within the instruction opcode).
  Also declare the string subsection to be the last one (just before bss).
  During build, manipulate the .o file: pad the unused space in the .strtab,
  and update the start of the bss section and all references to the bss section.
  All .bss data uses labels, which may not be exported if they end with $,
  so, need to find an option to have those present in the object file, and then
  removed from the final object file.
  Another approach is to have objcopy shrink the data section and do the .bss 
  relocation.


TODO: implement .bss
  declare bss start/size constants, and use those in pm kernel to memzero
  and update kernel end and calculate stack. Saves about 51k disk storage
  (even though the 1.44 floppy image still takes 1.44 mb in the iso).


BUG: [tcp_connections] gets overwritten

BUG: scheduler: [task_stack] gets overwritten with html

BUG: memleak: netq: does not drop packets when queue is full.
	Solution: have empty spot between tail/head always.
	(other solution: no empty spot, but, when head=tail, check whether
	the current index is occupied or not; if not, entire q is empty,
	otherwise, entire q is full; downside: requires knowledge of q content,
	so not generalizable.).

	addendum: there are some mallocs for net_rx_packet in print_handles$
	that are quite large: 0x0003336f (209kb).
	NOTE: this may be due to re-merging memory blocks and not a bug at all.

	new BUG: net_rx_queue not scheduled after reorg. probablyh
	becase of the 'inc' .. result is packet queue always full.
