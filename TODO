v Check Eltorito bootsector specification for CDROM.
  Currently a floppy is emulated.

  DONE: see DOC/Bootsector.txt


v include acpi.s breaks as
  Filed bug report.


v: bootloader writing. Currently destroys the target disk's previous
   data, as it writes to the MBR and succeeding sectors.

TODO: bootloader writing: write sector1 and following in the place indicated
  by the MBR. If writing to existing partition, allocate space using
  it's filesystem.

v: PMode. Provide: GDT (Global Descriptor Table)

v: Pmode IDT (Interrupt Table)

v: PIC remapping

v: implement keyboard driver in PMode (depends IDT)

TODO: Task Switching (TSS) (depends PMode)
  partly done - one TSS switch already works. Need to check whether
  a context switch really occurs to make sure.

TODO: construct memory map (ebda, bios rom etc).

TODO: implement Paging

TODO: test acpi_poweroff

TODO: Shell

TODO: filesystem

v: clean up bootloader, separate from kernel. Decisions:
	- whether sector1 is the kernel, or whether it is additional
	  bootloader code. At some point the kernel/sector1 will not
	  be succeeding the bootsector immediately, if compatability
	  with multi-os prepartitioned harddisks is desired.

	* Solution chosen is to separate sector1 into a stage 2 loader
	  and a kernel. The stage 2 loader at current uses a 'ramdisk',
	  a sector marking the start and length of images to be loaded.
	  At current only the first entry is used.
	  The kernel itself will check a signature at the end of it's compiled
	  code+data length to see if it is loaded in its entirety.
	
	- splitting: where to split sector1 from the kernel, where
	  is pmode entered? Goal is to use as little duplicate code as
	  possible.

	* Sector 1 used to include menu, inspector, pmode code. 
	  The 16 bit utilities have been moved and can still be included
	  in sector1, which now only contains the second stage loader code.
	  The pmode code has been moved to the kernel, aswell as all other
	  32 bit code.

	- whether to load the kernel in realmode or in pmode

	* The kernel is loaded in realmode. Loading in pmode would require:
	  o ATA (IDE) drivers; or
	  o VM86 task and monitor to allow BIOS calls; or
	  o switching to realmode for BIOS calls.

	  cons: the kernel loader code would already contain kernel code.
	  pros: kernel size can exceed the availale realmode size
	  of 0xf0000 - 0x4000 = 0xec000 = 966656 bytes = 944 kb when preserving
	  the IVT and BIOS - EBDA may be even before this.

	- whether to implement pmode drivers or do v86/realmode switching

	* Drivers shall be implemented in pmode. The current design then
	  has switched from a monolithic kernel which may grow too big,
	  to a microkernel with loadable modules.
	  The core functionality of the kernel then is to offer BIOS
	  functionality in protected mode: interrupts, irq (keyboard),
	  and storage device handlers.


TODO: load modules/objects/programs

TODO: have the sector1 code switch to pmode asap,
and update all the code used to linear addressing.
pmode needed for ACPI. 

TODO: create assembler

TODO: create high level programming language compiler

TODO: VM98 Mode (depends TSS)

TODO: APIC (Local, IO)

TODO: ELF Loader, KFS
	Compile (g++ test.c && objcopy -O elf32-i386 test.o test.o)
	Add to boot.img (write.exe ... -b test.o)
	Modify bootloader: pass on pointer to RAMDISK0
	Add code to kernel to access RAMDISK0 location - KFS.
	Load entry 1 (0=kernel), ELF image.
	Support REL and EXE; in case of EXE subtract base address from
	addresses to make 0-aligned.
	Iterate over relocation table:
		for each symbol update address:
			use kernel ELF image to locate symbol (and its address).
	Change makefile: store REL ELF binary of kernel image. 
	Update loader: locate .text section address (optionally add the
	entry address), and transfer control there.
		Pitfall: there will be data before and after the text section,
		so, need to make sure that the .text and .data sections
		are properly aligned in memory. Likely the ELF format
		does this properly. I assume that the ELF headers and tables
		will be stored before the blocks of data.
		(as to not replicate too much ELF code in the 16 bit loader)
	Keep track of all loaded ELF images as they will be the basis
	for the processes. 
	Finish kernel memory map: it already has access to the realmode
	data bios memory map. Needs to find a suitable memory segment
	for the kernel, for dynamic data maintenance, and for
	processes. Initial approach: take biggest memory segment,
	it'll be last usable one, above 1MB, extending to a little before
	physical memory end - the final segment of unusable data. Make sure
	algorithm can operate on any map ordering.
	Add relocation code. Perhaps split up the pmode code to have it just
	switch to pmode with all interrupts disabled,
	then return to the realmode loader code, do a memory move,
	then continue on with the setup of interrupts etc. Could also
	have the kernel do this, as the GDT needs to be adjusted:
		disable interrupts
		memmove
		update gdt (need to create 32 bit code)
		either zero out the lomem and use memory mapping,
		or zero out just the 32 bit part and keep track of
		the 16 bit kernel location and size.
	
	Investigate Local Descriptor Table. It may be possible to create
	new descriptors without modifying the GDT. In this case,
	create a segment descriptor for code, with limits according to
	the ELF information, aswell as a data selector and a stack
	selector. Find out what exception is generated for data overflows,
	potentially dynamic allocation (i.e. store parameters in registers,
	then access the last address the program expects to be addressable,
	having the gpf detect signature values in the registers to treat
	it like a malloc call.).

	Also, reserve some space BEFORE the elf header for a few simple
	pointers - heap start/end, stack etc.

	Implement ELF translation: assuming the entire image is in memory,
	create a copy by joining the appropriate sections; keep the sections
	(such as symboltable) that are useful.

	Decide whether to keep all process information together:
	process-header | elf headers | symboltable | code | data | stack | heap
	or whether to keep data of the same contextuals scope together:
	process-headers, symboltable... This allows for process mem layout
	to be STACK | CODE | DATA | HEAP.
	Otherwise: PROCESS INFO | LINKAGE | CODE | DATA | STACK | bss | HEAP

	Code needs an API to get a hold of brk()/heap start and end.
	Could either offer a pointer to the process layout, or specify
	a struct, such as     PROCESS INFO | CODE | DATA | ....
	or offer a kernel method that the linkage will refer to.


	ELF MODIFICATIONS:
	add new section type or use .notes or something to record library
	names and versions the file should be linked against. (cant check
	since creating an elf binary on cygwin needs to go through lots of
	weird options (-Wl,--oformat=elf32-i..), but -shared wont work...)
	
	Alternatively, encode the symbol names with library info,
	perhaps an index number into the new section. At current
	all symbols seem to be global, and only parameterizable by section,
	unless the compiler is changed to create elf files with split
	sections for symbol tables (referring to the same progbits/data),
	each section also recording the api name of the library.


Shell: argument escaping

	Use the parsed tokens, write a little grammar for them:
	see process_tokens in shell.s and trash/cd_apply.s


FileSystem: cd, ls

	ls: opendir, readent (in custom structure).

	ls uses fs_opendir which uses the internal filesystem tree
	to access mounted volumes.
	
	Each filesystem type has its own implementation (bits and
	pointers stored in the mtab).
	
	First attempt: simply only the ability to 
		mount hdb0 /a
		cd /a
		ls
	next attempt:
		mount hdb0 /a
		ls /a
	When this is unified, the next attempt is:
		ls /a/directory

	This will require some cleanup of:
		ata.s, partition.s, fs.s, fat.s, shell.s and hash.s.


Mounting filesystems:
	(mounting partitions already works, recording wise).

	Filesystems may be mounted on top of anything, so opendir
	should check for the longest match in mtab in order to find
	the proper filesystem handing code;
	for permissions and such, a top down approach should be applied.

	The opendir implementation then first checks mtab, and
	if there is no match it delegates to the current filesystem handler.

	The root handler then is the 'memory filesystem', containing
	the virtual root and the mount points,
	aswell as any other custom filesystems (such as a kernel filesystem
	or /dev and such).

	right now the mount point does not have to exist in order to mount
	there.

	
- i8254 does not immediately send packets, only when there are a number of
  them.

v realmode 'data' is slowly being pushed outside of the 64k range.
  option 1) Consider separating the realmode/pmode code, as the binary formats
    do not allow interleaving code/data segments. So, compile 2 obj files,
    and copy them. Don't want to use elf loading here as the code would need
    to be duplicated in pmode.
  option 2) define all data in .text for realmode/pmode/gdt/idt, anything
    doubly referenced.
  option 3) have a quick enter-pmode in the realmode.s, and
    do the dynamic setup of the GDT in pmode.s.

  DONE: option 2.


Optimize static string storage:

	the LOAD_TXT and similar macros define strings in the string
	section.
	Add a tool that rewrites the object file, removing duplicate
	strings, and using offsets into strings and such
	(.e. a="eax", b="ax" => a = "eax", b = a + 1)
	and using the string tables, to update references in code and data.

fdisk: ata_(get|print)_capacity reports 0 in VMWare

