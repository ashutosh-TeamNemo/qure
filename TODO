v Check Eltorito bootsector specification for CDROM.
  Currently a floppy is emulated.

  DONE: see DOC/Bootsector.txt


v include acpi.s breaks as
  Filed bug report.


v: bootloader writing. Currently destroys the target disk's previous
   data, as it writes to the MBR and succeeding sectors.

TODO: bootloader writing: write sector1 and following in the place indicated
  by the MBR. If writing to existing partition, allocate space using
  it's filesystem.

v: PMode. Provide: GDT (Global Descriptor Table)

v: Pmode IDT (Interrupt Table)

v: PIC remapping

v: implement keyboard driver in PMode (depends IDT)

TODO: Task Switching (TSS) (depends PMode)
  partly done - one TSS switch already works. Need to check whether
  a context switch really occurs to make sure.

TODO: construct memory map (ebda, bios rom etc).

TODO: implement Paging

TODO: test acpi_poweroff

TODO: Shell

TODO: filesystem

v: clean up bootloader, separate from kernel. Decisions:
	- whether sector1 is the kernel, or whether it is additional
	  bootloader code. At some point the kernel/sector1 will not
	  be succeeding the bootsector immediately, if compatability
	  with multi-os prepartitioned harddisks is desired.

	* Solution chosen is to separate sector1 into a stage 2 loader
	  and a kernel. The stage 2 loader at current uses a 'ramdisk',
	  a sector marking the start and length of images to be loaded.
	  At current only the first entry is used.
	  The kernel itself will check a signature at the end of it's compiled
	  code+data length to see if it is loaded in its entirety.
	
	- splitting: where to split sector1 from the kernel, where
	  is pmode entered? Goal is to use as little duplicate code as
	  possible.

	* Sector 1 used to include menu, inspector, pmode code. 
	  The 16 bit utilities have been moved and can still be included
	  in sector1, which now only contains the second stage loader code.
	  The pmode code has been moved to the kernel, aswell as all other
	  32 bit code.

	- whether to load the kernel in realmode or in pmode

	* The kernel is loaded in realmode. Loading in pmode would require:
	  o ATA (IDE) drivers; or
	  o VM86 task and monitor to allow BIOS calls; or
	  o switching to realmode for BIOS calls.

	  cons: the kernel loader code would already contain kernel code.
	  pros: kernel size can exceed the availale realmode size
	  of 0xf0000 - 0x4000 = 0xec000 = 966656 bytes = 944 kb when preserving
	  the IVT and BIOS - EBDA may be even before this.

	- whether to implement pmode drivers or do v86/realmode switching

	* Drivers shall be implemented in pmode. The current design then
	  has switched from a monolithic kernel which may grow too big,
	  to a microkernel with loadable modules.
	  The core functionality of the kernel then is to offer BIOS
	  functionality in protected mode: interrupts, irq (keyboard),
	  and storage device handlers.


TODO: load modules/objects/programs

TODO: have the sector1 code switch to pmode asap,
and update all the code used to linear addressing.
pmode needed for ACPI. 

TODO: create assembler

TODO: create high level programming language compiler

TODO: VM98 Mode (depends TSS)

TODO: APIC (Local, IO)
